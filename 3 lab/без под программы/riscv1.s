.text
__start:
.globl __start
lw a2, array_length # а2 = <длина массива>
la a3, array # а3 = <адрес 0-го элемента>
slli a4, a2, 2 # сдвигаем влево 2 раза
add a4, a3, a4 # прибавляем это к адрессу первого элемента
loop:
beq a3, a4, end # a3=a4, то выходим из цикла, переходя на end
lw a5, 0(a3) # элемент массива в a5
addi a6, a3, 0 # адрес элемента на котором мы сейчас
in_loop:
addi a6, a6, 4 # нужно делать +4 что бы перейти на след элемент массива
bgeu a6, a4, in_end # a6>=a4, то выходим из цикла, переходя на in_end
lw a7, 0(a6) # записываем элемент массива в a7
beq a5,a7, inc # eсли a5=a7, то переходим на inc
jal zero, in_loop # безусловный переход в начало вложенного цикла
inc:
addi t0, t0, 1 # добавляем 
jal zero, in_loop # безусловный переход в начало вложенного цикла
in_end:
addi t0, t0, 1 # добавляем 1 так как в любом случае взятое нами число 
# встречается минимум 1 раз
bgeu t0, s1, new_rez # если t0>=s1
jal zero, go # безусловный переход 
new_rez:
addi s0, a5, 0 # обновляем результат 
addi s1, t0, 0 # обновляем количество повторений результата
go:
li t0, 0 # обнуляем счетчик количества повторений
addi a3, a3, 4 # a3+1 нужно делать +4 что бы перейти на след элемент
jal zero, loop # безусловный переход в начало цикла
end:
addi a1, s0, 0 # записываем ответ в s0
li a0, 24 # записываем для вывода, когда в a0=24, 
# тогда из a1 значение мы выводим в консоль
ecall # выводим ответ
li a0,10 # когда в a0=10 мы завершаем программу
addi a1, s1, 0 # записываем ответ в s1
li a0, 24 # записываем для вывода, когда в a0=24, 
# тогда из a1 значение мы выводим в консоль
ecall # выводим ответ
li a0,10 # загружаем 10 что бы вывести в консоль
ecall # конец работы
.rodata
array_length:
.word 5
.rodata
array:
.word 3,1,2,2,2